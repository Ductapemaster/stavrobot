# Stavrobot

![](misc/stavrobot.jpg)

A personal AI assistant with persistent memory, sandboxed code execution, and Signal and Telegram integration.

## Features

- **Security.** The bot runs in isolated containers with no access to the host system. Code execution is sandboxed with no access to secrets. Signal and Telegram allowlists restrict who can interact with the agent. You can run it on your personal PC with no fear.
- **Low token usage.** Various optimizations have been made to be light on token usage. We even use [TOON](https://github.com/toon-format/toon) internally.
- **Plugins.** Install plugins and extend Stavrobot's capabilities by just giving it a git repo URL. Plugins are isolated from each other — each runs as a dedicated system user with no access to other plugins' files or configuration.
- **Signal integration.** Two-way messaging via signal-cli, including voice note transcription (OpenAI STT).
- **Telegram integration.** Two-way messaging via a Telegram bot webhook, including voice note transcription (OpenAI STT).
- **Three-tier knowledge.** Tier 1 (memories): a self-managed memory store injected into the system prompt every turn — for things the agent needs constantly. Tier 2 (scratchpad): titled entries whose titles are always in context but whose bodies are loaded on demand — for important but less-frequently needed knowledge. Tier 3 (database): full read/write access to PostgreSQL via unrestricted SQL — the agent can create tables, query, and store anything.
- **Subagents.** The main agent can create subagents with their own conversation context, system prompt, and restricted tool access. Useful for talking to outside people to complete tasks or arrange things, while having a buffer between the outside person and the main agent.
- **Self-programming.** The agent can request a secondary coding agent to create new tools at runtime. Tools are executable scripts with a JSON manifest, discovered and invoked by the main agent.
- **Sandboxed Python execution.** Arbitrary Python with pip dependencies via `uv`, isolated from the host environment.
- **Cron scheduling.** The agent can schedule its own recurring or one-shot reminders.
- **Web search and fetch.** Optional tools for searching the web and fetching/analyzing URLs via sub-agent LLM calls.
- **Database explorer.** A web UI at `/explorer` for browsing PostgreSQL tables, viewing schemas, and paginating through rows.
- **Plugin manager.** A web UI at `/plugins` for browsing installed plugins, installing new ones from git URLs, updating, deleting, and editing plugin configuration.
- **Apps.** The agent can create dynamic web apps. Apps are private (auth-required) by default, with an option to make individual pages public.
- **Conversation compaction.** Auto-summarizes long conversation histories to stay within context limits.

## Setup

### Config

1. Copy `config.example.toml` to `data/main/config.toml`.
2. Fill in API keys and settings. The example file has comments explaining each section.
3. At minimum, set `authFile` (or `apiKey`) and `publicHostname`. Everything else is optional.
4. Copy `env.example` to `.env` and set your timezone (`TZ`). Postgres credentials and other environment settings can also be overridden there. The defaults work out of the box with docker-compose.

### Claude Code setup

The `coder` container uses Claude Code with subscription auth (OAuth), separate from the main app's API key.

1. Start the containers: `docker compose up --build`
2. Log in: `docker compose exec -u coder coder claude` (it will prompt you to log in if you haven't).
3. Follow the browser-based OAuth flow.
4. Set `[coder].model` in your config to a Claude Code model alias (`sonnet`, `opus`, or `haiku`).

### Signal setup

Signal requires a **separate phone number** — not your personal one. A prepaid SIM or VoIP number works.

1. Uncomment `COMPOSE_PROFILES=signal` in your `.env` file to enable the signal-bridge container.
2. Start the containers: `docker compose up --build`
3. Exec into the signal-bridge container: `docker compose exec signal-bridge bash`
4. Register: `signal-cli -u +YOUR_NUMBER register`
5. Verify with the code you receive: `signal-cli -u +YOUR_NUMBER verify CODE`
6. Set `[signal].account` and `[signal].allowedNumbers` in your config.
7. See the [signal-cli quickstart](https://github.com/AsamK/signal-cli/wiki/Quickstart) for details.

### Telegram setup

1. Message @BotFather on Telegram, create a new bot, and copy the token.
2. Message @userinfobot on Telegram to get your chat ID.
3. Set `[telegram].botToken`, `[telegram].webhookHost`, and `[telegram].allowedChatIds` in your config.
4. The webhook is registered automatically when the app starts.

### Running

```bash
docker compose up --build
```

The API is available at `http://localhost:10567/chat`. A Python CLI client (`client.py`) is included for interactive use.

### Without Docker

Requires Node.js >= 20 and a running PostgreSQL instance.

```bash
npm install && npm run build && npm start
```

Note: Python execution and Signal integration only work inside the Docker containers.

## Knowledge system

Stavrobot has a three-tier knowledge system: **memories**, a **scratchpad**, and the
**database**. It will manage these fairly well on its own, but they're important for you
to know because you will want to help the bot use them properly.

**Memories** are always injected into the system prompt wholesale. You should be frugal
with these, as they get included in the context every time, and having many of them can
increase the context. An example of a good memory would be "the user prefers chatting in
an informal style.", something that the bot should know about every time, even if that
costs in additional context length.

**The scratchpad** is where the bot keeps less frequently-accessed knowledge, but
knowledge that pertains to a topic. Scratchpad entries have a title and a body, and the
title gets injected into the context automatically. Use this for important, but
less-frequently needed things, things that usually pertain to a specific topic.

For example, a good scratchpad entry would be "dietary preferences", with details about
what you like to eat, when, etc. The bot will see that there's a topic "dietary
preferences", but not load the actual text itself into the context automatically, only
accessing it on-demand.

When you're talking to the bot about food, it will know there's a "dietary preferences"
scratchpad entry it can look at, and usually do that on its own.

**The database** is the third tier, for structured or bulk data that doesn't belong in
memories or the scratchpad. The bot has full read/write access to PostgreSQL via
unrestricted SQL, so it can create tables, run queries, and store anything. Use this for
things like lists, logs, structured records, or any data that's better queried than read
as prose.

The bot will usually know well enough what to use when, but sometimes you will want to
tell it explicitly what information to put where.

## Skills

Skills are plain-text instruction files that teach the bot new capabilities — things like
creating tables, storing knowledge, making pages, or following specific workflows. They
are not code; they are natural-language instructions the bot reads and follows.

To install the skill system, tell the bot to fetch
`https://stavrobot.stavros.io/bootstrap.md` and follow its instructions.

A full list of available skills is at
`https://stavrobot.stavros.io/skills/index.md`. To install a skill, just tell the bot to
fetch and install it from that URL. The bot will show you what the skill does and ask for
confirmation before proceeding.

Skill files live on the `pages` branch of this repo (served via Cloudflare Pages). To
contribute a skill, add a markdown file to `skills/` on that branch. Each skill file has
YAML front matter with `title`, `description`, `version`, and an optional `author`,
followed by the plain-language instructions in the body. See
[SKILL-AUTHORING.md](misc/SKILL-AUTHORING.md) for the full authoring guide. Submit a PR
against the `pages` branch.

## How to make your own plugin

See [PLUGIN.md](coder/PLUGIN.md) for everything you need to know to create a Stavrobot plugin. The same document works as a reference for both humans and LLMs.

## Recommended plugins

- Google Calendar: Ask Stavrobot to install https://github.com/stavrobot/plugin-google-calendar.git
- Google Flights: Ask Stavrobot to install https://github.com/stavrobot/plugin-flights.git
- Weather: Ask Stavrobot to install https://github.com/stavrobot/plugin-weather.git
- Hacker News front page: Ask Stavrobot to install https://github.com/stavrobot/plugin-hackernews.git

## Architecture

Four Docker containers: `app` (TypeScript server, exposes `POST /chat` on port 3000 and handles Telegram webhooks at `POST /telegram/webhook`), `postgres` (PostgreSQL 17 for persistent state), `plugin-runner` (Node.js server — lists, inspects, and executes plugins, both locally created and git-installed), and `coder` (Claude Code headless agent for creating and modifying editable plugins). The main agent can create subagents, each with their own conversation history, system prompt, and tool whitelist. Interlocutors are contact records assigned to agents for inbound message routing.

## License

[AGPL-3.0](LICENSE)
