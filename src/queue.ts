import type pg from "pg";
import type { Agent } from "@mariozechner/pi-agent-core";
import type { Config } from "./config.js";
import { handlePrompt } from "./agent.js";
import { AuthError } from "./auth.js";
import { sendSignalMessage } from "./signal.js";
import { sendTelegramMessage } from "./telegram-api.js";
import type { FileAttachment } from "./uploads.js";
import { getMainAgentId, isOwnerIdentity, resolveInterlocutor, loadAgent } from "./database.js";

const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 30_000;

export interface RoutingResult {
  agentId: number;
  senderIdentityId: number | undefined;
  senderAgentId: number | undefined;
  senderLabel: string;
  isMainAgent: boolean;
}

interface QueueEntry {
  message: string | undefined;
  source: string | undefined;
  sender: string | undefined;
  audio: string | undefined;
  audioContentType: string | undefined;
  attachments: FileAttachment[] | undefined;
  targetAgentId: number | undefined;
  retries: number;
  resolve: (value: string) => void;
  reject: (reason: unknown) => void;
}

const queue: QueueEntry[] = [];
let processing = false;

let queueAgent: Agent | undefined;
let queuePool: pg.Pool | undefined;
let queueConfig: Config | undefined;

export function initializeQueue(agent: Agent, pool: pg.Pool, config: Config): void {
  queueAgent = agent;
  queuePool = pool;
  queueConfig = config;
}

function sleep(milliseconds: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

// Internal sources are system-generated (not from external interlocutors) and
// always route to the owner conversation.
function isInternalSource(source: string): boolean {
  return source === "cli" || source === "cron" || source === "coder" || source.startsWith("plugin:");
}

async function resolveTargetAgent(
  pool: pg.Pool,
  source: string | undefined,
  sender: string | undefined,
  targetAgentId: number | undefined,
): Promise<RoutingResult | null> {
  const mainAgentId = getMainAgentId();

  // Agent-to-agent message: targetAgentId must be set.
  if (source === "agent") {
    if (targetAgentId === undefined) {
      return null;
    }
    const senderAgentId = sender !== undefined ? Number(sender) : undefined;
    let senderLabel = "agent";
    if (senderAgentId !== undefined) {
      const senderAgent = await loadAgent(pool, senderAgentId);
      if (senderAgent !== null) {
        senderLabel = `${senderAgent.name} (ID: ${senderAgentId})`;
      }
    }
    return {
      agentId: targetAgentId,
      senderIdentityId: undefined,
      senderAgentId,
      senderLabel,
      isMainAgent: targetAgentId === mainAgentId,
    };
  }

  // If targetAgentId is set on a non-agent source, use it directly.
  if (targetAgentId !== undefined) {
    return {
      agentId: targetAgentId,
      senderIdentityId: undefined,
      senderAgentId: undefined,
      senderLabel: source ?? "unknown",
      isMainAgent: targetAgentId === mainAgentId,
    };
  }

  // Pure CLI call: no source and no sender. Route to main agent.
  if (source === undefined && sender === undefined) {
    return {
      agentId: mainAgentId,
      senderIdentityId: undefined,
      senderAgentId: undefined,
      senderLabel: "owner",
      isMainAgent: true,
    };
  }

  // Named internal sources (cli, cron, coder, plugin:*) always go to main agent.
  if (source !== undefined && isInternalSource(source)) {
    return {
      agentId: mainAgentId,
      senderIdentityId: undefined,
      senderAgentId: undefined,
      senderLabel: source,
      isMainAgent: true,
    };
  }

  // External messages require both source and sender. Drop if either is missing.
  if (source === undefined || sender === undefined) {
    return null;
  }

  // If the sender matches the owner's configured identities, route to main agent
  // without a DB lookup.
  if (isOwnerIdentity(source, sender)) {
    return {
      agentId: mainAgentId,
      senderIdentityId: undefined,
      senderAgentId: undefined,
      senderLabel: "owner",
      isMainAgent: true,
    };
  }

  // Look up the sender in the interlocutor_identities table (soft gate).
  const interlocutor = await resolveInterlocutor(pool, source, sender);
  if (interlocutor === null) {
    return null;
  }
  return {
    agentId: interlocutor.agentId,
    senderIdentityId: interlocutor.identityId,
    senderAgentId: undefined,
    senderLabel: interlocutor.displayName,
    isMainAgent: interlocutor.agentId === mainAgentId,
  };
}

async function processQueue(): Promise<void> {
  processing = true;
  while (queue.length > 0) {
    const entry = queue.shift()!;
    if (process.env.STAVROBOT_DEBUG === "1") {
      const preview = (entry.message ?? "").slice(0, 200);
      console.log(`[stavrobot] [debug] Received: ${entry.source} - ${entry.sender} - ${preview}`);
    }
    try {
      const routing = await resolveTargetAgent(queuePool!, entry.source, entry.sender, entry.targetAgentId);
      if (routing === null) {
        console.warn(`[stavrobot] Dropping message: could not resolve target agent. source=${entry.source}, sender=${entry.sender}`);
        entry.resolve("");
        continue;
      }
      const response = await handlePrompt(queueAgent!, queuePool!, entry.message, queueConfig!, routing, entry.source, entry.audio, entry.audioContentType, entry.attachments);
      entry.resolve(response);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (error instanceof AuthError) {
        console.error(`[stavrobot] Auth failure, not retrying: ${errorMessage}`);
        const loginMessage = `Authentication required. Visit ${queueConfig!.publicHostname}/providers/anthropic/login to log in.`;
        if (entry.source === "signal" && entry.sender !== undefined) {
          try {
            await sendSignalMessage(entry.sender, loginMessage);
          } catch (sendError) {
            console.error(`[stavrobot] Failed to send Signal login notification: ${sendError instanceof Error ? sendError.message : String(sendError)}`);
          }
        } else if (entry.source === "telegram" && entry.sender !== undefined) {
          try {
            await sendTelegramMessage(queueConfig!.telegram!.botToken, entry.sender, loginMessage);
          } catch (sendError) {
            console.error(`[stavrobot] Failed to send Telegram login notification: ${sendError instanceof Error ? sendError.message : String(sendError)}`);
          }
        }
        entry.resolve(loginMessage);
      } else if (errorMessage.includes("400 {")) {
        console.error(`[stavrobot] Non-retryable API error (400 client error), not retrying: ${errorMessage}`);
        entry.resolve("Something went wrong processing your message. Please try again.");
      } else if (entry.retries < MAX_RETRIES) {
        const attempt = entry.retries + 1;
        console.log(`[stavrobot] Message failed (attempt ${attempt}/${MAX_RETRIES + 1}), retrying in ${RETRY_DELAY_MS / 1000}s: ${errorMessage}`);
        await sleep(RETRY_DELAY_MS);
        queue.push({ ...entry, retries: attempt });
      } else {
        console.error(`[stavrobot] Message failed after ${MAX_RETRIES + 1} attempts, giving up: ${errorMessage}`);
        entry.reject(error);
      }
    }
  }
  processing = false;
}

export function enqueueMessage(
  message: string | undefined,
  source?: string,
  sender?: string,
  audio?: string,
  audioContentType?: string,
  attachments?: FileAttachment[],
  targetAgentId?: number,
): Promise<string> {
  return new Promise<string>((resolve, reject) => {
    queue.push({ message, source, sender, audio, audioContentType, attachments, targetAgentId, retries: 0, resolve, reject });
    if (!processing) {
      void processQueue();
    }
  });
}
